import{_ as r}from"./chunks/GVTruthTable.Cy7boSWx.js";import{_ as s,B as i,c as a,o as b,j as l,a3 as n,a as e,G as p,n as d}from"./chunks/framework.CM9Y3eBy.js";const m="_mono_table_body_pvtdw_3",c="_no_mono_pvtdw_8",f={mono_table_body:m,no_mono:c},k=JSON.parse('{"title":"真值表","description":"","frontmatter":{},"headers":[],"relativePath":"zh/base/shift/truth_table.md","filePath":"zh/base/shift/truth_table.md"}'),y={name:"zh/base/shift/truth_table.md"},C={id:"真值表",tabindex:"-1"};function g(o,t,N,T,x,B){const u=i("Badge");return b(),a("div",{"data-pagefind-body":!0},[l("h1",C,[t[0]||(t[0]=e("真值表 ")),p(u,{text:"v1.0",type:"info"}),t[1]||(t[1]=e()),t[2]||(t[2]=l("a",{class:"header-anchor",href:"#真值表","aria-label":'Permalink to "真值表 <Badge text="v1.0" type="info"/>"'},"​",-1))]),t[29]||(t[29]=n('<img src="'+r+'" alt="GV真值表 图示" class="center_image small"><p>包含表征逻辑事件输入和输出之间全部可能状态表格的元件，除了能像经典版一样根据指定的输入输出电压，还能根据表达式进行计算；该元件的端口定义与原版相同，不再复述</p><h2 id="规则例子" tabindex="-1">规则例子 <a class="header-anchor" href="#规则例子" aria-label="Permalink to &quot;规则例子&quot;">​</a></h2><p>规则的计算表达式基于 <a href="https://github.com/sklose/NCalc2" target="_blank" rel="noreferrer">NCalc2</a>，写法类似于 <a href="https://support.microsoft.com/zh-cn/office/excel-%E4%B8%AD%E7%9A%84%E5%85%AC%E5%BC%8F%E6%A6%82%E8%BF%B0-ecfdc708-9162-49e8-b993-c311f47ca173" target="_blank" rel="noreferrer">Excel公式</a>，请先看具体例子：</p><ul><li><code>1;2;3;4:5</code></li></ul>',5)),l("table",{class:d(o.$style.mono_table_body)},t[3]||(t[3]=[l("thead",null,[l("tr",null,[l("th",null,"端口"),l("th",null,"上端"),l("th",null,"右端"),l("th",null,"下端"),l("th",null,"左端")])],-1),l("tbody",null,[l("tr",null,[l("td",null,"当前输入"),l("td",null,"= 1"),l("td",null,"= 2"),l("td",null,"= 3"),l("td",null,"= 4")]),l("tr",null,[l("td",null,"输出"),l("td",{colspan:"4"},"5")])],-1)]),2),t[30]||(t[30]=l("ul",null,[l("li",null,[l("code",null,">0x1;<=0xA;i3>1&&i3<99:0xABC")])],-1)),l("table",{class:d(o.$style.mono_table_body)},t[4]||(t[4]=[l("thead",null,[l("tr",null,[l("th",null,"端口"),l("th",null,"上端"),l("th",null,"右端"),l("th",null,"下端"),l("th",null,"左端")])],-1),l("tbody",null,[l("tr",null,[l("td",null,"当前输入"),l("td",null,"> 0x1"),l("td",null,"≤ 0xA"),l("td",null,"> 1 且 < 99"),l("td",null,"任意值")]),l("tr",null,[l("td",null,"输出"),l("td",{colspan:"4"},"0xABC")])],-1)]),2),t[31]||(t[31]=l("ul",null,[l("li",null,[l("code",null,"0;0;0;0;;i2;true;>i1:10")])],-1)),l("table",{class:d(o.$style.mono_table_body)},t[5]||(t[5]=[l("thead",null,[l("tr",null,[l("th",null,"端口"),l("th",null,"上端"),l("th",null,"右端"),l("th",null,"下端"),l("th",null,"左端")])],-1),l("tbody",null,[l("tr",null,[l("td",null,"上 1 轮输入"),l("td",null,"= 0"),l("td",null,"= 0"),l("td",null,"= 0"),l("td",null,"= 0")]),l("tr",null,[l("td",null,"当前输入"),l("td",null,"= 右端输入"),l("td",null,"任意值"),l("td",null,"> 上端输入"),l("td",null,"任意值")]),l("tr",null,[l("td",null,"输出"),l("td",{colspan:"4"},"10")])],-1)]),2),t[32]||(t[32]=l("ul",null,[l("li",null,[l("code",null,"0;;1;;2;;3:4::5:6::7:8")])],-1)),l("table",{class:d(o.$style.mono_table_body)},[t[27]||(t[27]=l("thead",null,[l("tr",null,[l("th",null,"规则组"),l("th",null,"端口"),l("th",null,"上端"),l("th",null,"右端"),l("th",null,"下端"),l("th",null,"左端")])],-1)),l("tbody",null,[l("tr",null,[t[6]||(t[6]=l("td",{rowspan:"5"},"1",-1)),l("td",{class:d(o.$style.no_mono)},"上 3 轮输入",2),t[7]||(t[7]=l("td",null,"= 0",-1)),t[8]||(t[8]=l("td",null,"任意值",-1)),t[9]||(t[9]=l("td",null,"任意值",-1)),t[10]||(t[10]=l("td",null,"任意值",-1))]),t[21]||(t[21]=l("tr",null,[l("td",null,"上 2 轮输入"),l("td",null,"= 1"),l("td",null,"任意值"),l("td",null,"任意值"),l("td",null,"任意值")],-1)),t[22]||(t[22]=l("tr",null,[l("td",null,"上 1 轮输入"),l("td",null,"= 2"),l("td",null,"任意值"),l("td",null,"任意值"),l("td",null,"任意值")],-1)),t[23]||(t[23]=l("tr",null,[l("td",null,"当前输入"),l("td",null,"= 3"),l("td",null,"任意值"),l("td",null,"任意值"),l("td",null,"任意值")],-1)),t[24]||(t[24]=l("tr",null,[l("td",null,"输出"),l("td",{colspan:"4"},"10")],-1)),l("tr",null,[t[11]||(t[11]=l("td",{rowspan:"2"},"2",-1)),l("td",{class:d(o.$style.no_mono)},"当前输入",2),t[12]||(t[12]=l("td",null,"= 5",-1)),t[13]||(t[13]=l("td",null,"任意值",-1)),t[14]||(t[14]=l("td",null,"任意值",-1)),t[15]||(t[15]=l("td",null,"任意值",-1))]),t[25]||(t[25]=l("tr",null,[l("td",null,"输出"),l("td",{colspan:"4"},"6")],-1)),l("tr",null,[t[16]||(t[16]=l("td",{rowspan:"2"},"3",-1)),l("td",{class:d(o.$style.no_mono)},"当前输入",2),t[17]||(t[17]=l("td",null,"= 6",-1)),t[18]||(t[18]=l("td",null,"任意值",-1)),t[19]||(t[19]=l("td",null,"任意值",-1)),t[20]||(t[20]=l("td",null,"任意值",-1))]),t[26]||(t[26]=l("tr",null,[l("td",null,"输出"),l("td",{colspan:"4"},"7")],-1))])],2),t[33]||(t[33]=l("ul",null,[l("li",null,[l("code",null,"true;true;Min(i1,i2),Max(i1,i2):i1+i2")])],-1)),l("table",{class:d(o.$style.mono_table_body)},t[28]||(t[28]=[l("thead",null,[l("tr",null,[l("th",null,"端口"),l("th",null,"上端"),l("th",null,"右端"),l("th",null,"下端"),l("th",null,"左端")])],-1),l("tbody",null,[l("tr",null,[l("td",null,"当前输入"),l("td",null,"任意值"),l("td",null,"任意值"),l("td",null,"= 上端输入 和 右端输入 中更小的"),l("td",null,"= 上端输入 和 右端输入 中更大的")]),l("tr",null,[l("td",null,"输出"),l("td",{colspan:"4"},"上端输入 + 右端输入")])],-1)]),2),t[34]||(t[34]=n('<h2 id="具体用法" tabindex="-1">具体用法 <a class="header-anchor" href="#具体用法" aria-label="Permalink to &quot;具体用法&quot;">​</a></h2><p>通过以上例子，你可能已经对十亿伏特真值表用法有了初步的认识，下面是具体用法</p><ul><li>4 个输入规则之间用英文分号<code>;</code>分隔，顺序为<code>上端</code>​<code>右端</code>​<code>下端</code>​<code>左端</code>，之后为表述方便，其输入分别称作为<code>输入 1</code>​<code>输入 2</code>​<code>输入 3</code>​<code>输入 4</code>，而其值在表达式中分别写作<code>i1</code>​<code>i2</code>​<code>i3</code>​<code>i4</code></li><li>如果输入 1、2 需要设定规则，输入 3、4 可以为任意值，则输入 3、4的规则可以省略不写，但也不能加上多余的<code>;</code></li><li>如果要给输入 1、3设定规则，而输入 2 可以为任意值，需要给输入 2 设定规则<code>true</code></li><li>如果输入规则的开头是<code>=</code>​<code>!=</code>​<code>&gt;</code>​<code>&lt;</code>这四种运算符之一，真值表会根据这是第几个输入，自动在开头加上<code>i1</code>​<code>i2</code>​<code>i3</code>​<code>i4</code>，当然你也可以自己加上</li><li>如果输入规则不是<code>true</code>，且不包含<code>=</code>​<code>!</code>​<code>not</code>​<code>&gt;</code>​<code>&lt;</code>​<code>and</code>​<code>&amp;&amp;</code>​<code>||</code>​<code>or</code>中的任意一个运算符，此Mod会自动在开头加上<code>i1=</code>​<code>i2=</code>​<code>i3=</code>​<code>i4=</code></li><li>使用两个英文分号<code>;;</code>来分隔时序，越左边时序越早，最右边的时序是现在的输入，最多取得 15 轮次之前的输入</li><li>每次输入发生变化时，轮次加 1</li><li>只有输入规则的计算结果是<code>true</code>时，才会计算下一个输入规则，然后计算下一组时序，直到所有规则计算结果均为<code>true</code>，才会输出此组规则设定的输出</li><li>使用英文冒号<code>:</code>来分隔输入规则和输出规则，输出规则的计算结果必须为自然数（&gt;=0 的整数）</li><li>使用两个英文冒号<code>::</code>来分隔多组输入输出规则，当第一组规则不输出时，则计算下一组规则，直到有输出为止，不再计算下一组规则，最多 2<sup>32</sup>-1 组规则</li><li>过程中出现任何错误均会直接停止计算并输出 0 V，错误详见游戏日志</li><li>数字默认为十进制，如要使用十六进制数字，请在十六进制数字前加上<code>0x</code>，二进制则在其前面加上<code>0b</code>，非十进制时不支持小数点</li></ul><div class="warning custom-block github-alert"><p class="custom-block-title">⚠️ 注意</p><p>规则对大小写敏感！</p></div><h2 id="关于-ncalc" tabindex="-1">关于 NCalc <a class="header-anchor" href="#关于-ncalc" aria-label="Permalink to &quot;关于 NCalc&quot;">​</a></h2><p>如果想了解更多有关 NCalc 的信息，可阅读：</p><ul><li><a href="./ncalc/operators.html">NCalc 运算符</a> <code>= &gt; &lt; + - * /</code>等</li><li><a href="./ncalc/functions.html">NCalc 函数</a> <code>if Max Sin</code>等<br> 其中三角函数的输入应为弧度，本 mod 额外提供<code>Atan2 Cosh Sinh Tanh</code>，此类函数计算前会先将数字转换为双精度浮点数，再进行计算，而且过程中保留小数，输出时会自动去除小数部分<br> 另外，<code>Round</code>使用两个参数会得出奇怪结果，本 mod 未能解决</li><li><a href="./ncalc/values.html">NCalc 数值</a> <code>9876 1.23e9 true false</code>等<br> 额外提供<code>PI() E()</code>来获取圆周率 π、自然常数 <em>e</em></li></ul>',7))])}const A={$style:f},E=s(y,[["render",g],["__cssModules",A]]);export{k as __pageData,E as default};
