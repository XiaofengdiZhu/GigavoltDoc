import{_ as e}from"./chunks/GVJavascriptMicrocontrollerBlock.CsKLx3-n.js";import{_ as r,o as d,c as a,a3 as o}from"./chunks/framework.C-GLQy3h.js";const u=JSON.parse('{"title":"JS 单片机","description":"","frontmatter":{},"headers":[],"relativePath":"zh/expand/gates/javascript_microcontroller.md","filePath":"zh/expand/gates/javascript_microcontroller.md"}'),n={name:"zh/expand/gates/javascript_microcontroller.md"};function s(i,t,c,l,m,h){return d(),a("div",{"data-pagefind-body":!0},t[0]||(t[0]=[o('<h1 id="js-单片机" tabindex="-1">JS 单片机 <a class="header-anchor" href="#js-单片机" aria-label="Permalink to &quot;JS 单片机&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><img alt="JS单片机 图示" src="'+e+'" class="center_image small"><p>可以运行 <a href="https://javascript.info/" target="_blank" rel="noreferrer">Javascript</a>（简称 JS）脚本的单片机，理论上可实现一切功能</p><p>使用前，需要先编辑它来指定哪些端口为输入，哪些端口为输出，之后每当输入电压发生变化时，都会运行一遍保存在其中的 JS 脚本，如运行错误会在游戏日志中报错</p><p>每一个 JS 单片机的运行环境都是独立的，而一个 JS 单片机中创建的变量、方法会一直保留（但不会保存进存档），强烈建议在初始化相关代码前判断是否需要初始化，否则容易触发重复声明的错误</p><h2 id="内置变量" tabindex="-1">内置变量 <a class="header-anchor" href="#内置变量" aria-label="Permalink to &quot;内置变量&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">内置变量</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center;">P0</td><td>后端口的电压。当后端口是输入时，可通过此变量来读取后端口的电压，赋值无效；当后端口是输出时，可通过给该变量赋值来输出指定电压</td></tr><tr><td style="text-align:center;">P1</td><td>上端口的电压，其余同上</td></tr><tr><td style="text-align:center;">P2</td><td>右端口的电压，其余同上</td></tr><tr><td style="text-align:center;">P3</td><td>下端口的电压，其余同上</td></tr><tr><td style="text-align:center;">P4</td><td>左端口的电压，其余同上</td></tr><tr><td style="text-align:center;">System</td><td>.Net 的 System 命名空间</td></tr><tr><td style="text-align:center;">Game</td><td>游戏的 Game 命名空间</td></tr><tr><td style="text-align:center;">Engine</td><td>游戏的 Engine 命名空间</td></tr><tr><td style="text-align:center;">GameEntitySystem</td><td>游戏的 GameEntitySystem 命名空间</td></tr><tr><td style="text-align:center;">Project</td><td>当前游戏存档的Project对象</td></tr></tbody></table><h2 id="内置方法" tabindex="-1">内置方法 <a class="header-anchor" href="#内置方法" aria-label="Permalink to &quot;内置方法&quot;">​</a></h2><table tabindex="0"><thead><tr><th>内置方法</th><th>说明</th></tr></thead><tbody><tr><td>getPosition()</td><td>返回该JS单片机所在位置，返回类型为<code>Engine.Point3</code>，内有<code>X</code>​<code>Y</code>​<code>Z</code>三个字段来表示坐标</td></tr><tr><td>getPortState(number)</td><td>返回指定端口的输入输出状态，参数需要输入0到4的整数，如果是输入则返回字符串<code>input</code>，输出<code>output</code>，禁用<code>disabled</code>，参数错误则返回<code>error</code></td></tr><tr><td>setPortDisabled(number)</td><td>设置指定端口为禁用，参数需要是0到4的整数</td></tr><tr><td>setPortInput(number)</td><td>设置指定端口为输入，参数需要是0到4的整数</td></tr><tr><td>setPortOutput(number)</td><td>设置指定端口为输出，参数需要是0到4的整数</td></tr><tr><td>importNamespace(string)</td><td>导入并返回命名空间</td></tr><tr><td>findSubsystem(string)</td><td>根据名称返回当前游戏存档的Subsystem，参数开头不要带Subsystem</td></tr><tr><td>executeAgain(number)</td><td>让该JS单片机在电路运行n个循环后无视输入是否变化，再次自发执行脚本；如果在一次执行中多次使用该方法，以最后设置的n为准；n小于等于0则取消；如果自发执行脚本前因输入变化而执行，此方法取消</td></tr></tbody></table><blockquote><p>请务必先设置输入端口，否则脚本完全不会运行</p></blockquote>',11)]))}const g=r(n,[["render",s]]);export{u as __pageData,g as default};
