import{E as e,a as n,b as a,c as r,I as t,d as o}from"./chunks/ElectricElement.BuvPvndk.js";import{d as x,o as u,c as b,j as s,a as d,I as l,k as i,a5 as c,D as y}from"./chunks/framework.CZYz2WcB.js";import"./chunks/locale.CB2Y0rC6.js";const g={id:"多存储器操作器",tabindex:"-1"},f=s("a",{class:"header-anchor",href:"#多存储器操作器","aria-label":'Permalink to "多存储器操作器 <Badge text="v1.0" type="info"/>"'},"​",-1),w=c('<h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>有两种用途，一种是对两个存储器进行合并、取交集等操作，下面称之为一般操作；另一种用途是批量初始化多个存储器</p><h2 id="一般操作" tabindex="-1">一般操作 <a class="header-anchor" href="#一般操作" aria-label="Permalink to &quot;一般操作&quot;">​</a></h2><p>左右两边各指定一个存储器 ID，按下端输入进行不同操作后，将结果输出到由上端输入指定 ID 的存储器</p><p>上左右都应该指定正确的存储器 ID，只有在下端为 1 时允许右端指定 ID 的存储器不存在，否则将不进行任何操作</p><p>而复制以外的操作，输出存储器的高度将被设置为 1，宽度被设置为数据总数量，因此推荐输出到可手动设置宽高的一维存储器</p><h3 id="端口定义" tabindex="-1">端口定义 <a class="header-anchor" href="#端口定义" aria-label="Permalink to &quot;端口定义&quot;">​</a></h3>',7),_=c('<h3 id="下端同步操作" tabindex="-1">下端同步操作 <a class="header-anchor" href="#下端同步操作" aria-label="Permalink to &quot;下端同步操作&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:center;">电压</th><th style="text-align:center;">操作</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">0 或<br>未指定</td><td style="text-align:center;">无</td><td style="text-align:left;">当下端输入变化时才会进行操作，不会因其他端口输入电压改变而立即执行操作</td></tr><tr><td style="text-align:center;">1</td><td style="text-align:center;">合并<br>/复制</td><td style="text-align:left;">将左右两边存储器的所有数据直接合并，左边存储器的数据在前，右边存储器的数据在后<br>如果右端指定ID的存储器不存在，而左边存在，则相当于复制左边数据<br>复制时，需要确保左边存储器与输出存储器类型一致（是否是易失版不影响）</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">插入</td><td style="text-align:left;">将右边存储器的所有数据插入左边存储器，可使用后端输入指定插入的位置（从 0 开始）<br>如果指定位置大于左边存储器的数据数量，则会在中间补 0</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">覆盖</td><td style="text-align:left;">将右边存储器的所有数据覆盖到左边存储器，可使用后端输入指定覆盖开始的位置（从 0 开始）<br>如果指定位置大于左边存储器的数据数量，则会在中间补 0</td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;">交集</td><td style="text-align:left;">将左边存储器的数据逐一与右边比对，如果右边也存在则保留，否则删除</td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;">交集<br>（去重）</td><td style="text-align:left;">同上，但还会对结果进行去重</td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;">差集</td><td style="text-align:left;">将左边存储器的数据逐一与右边比对，如果右边存在则删除，否则保留</td></tr><tr><td style="text-align:center;">7</td><td style="text-align:center;">差集<br>（去重）</td><td style="text-align:left;">同上，但还会对结果进行去重</td></tr></tbody></table><div class="tip custom-block github-alert"><p class="custom-block-title">📝 关于指定插入、覆盖开始的位置</p><p>例如要将数据插入到第 5、6 个数据之间，则后端应该输入 5；要插入到第 1 个数据之前，则后端应该输入 0<br> 要从第 5 个数据开始覆盖，则后端应该输入 4；要从第 1 个数据开始覆盖，则后端应该输入 0</p></div><h2 id="批量初始化" tabindex="-1">批量初始化 <a class="header-anchor" href="#批量初始化" aria-label="Permalink to &quot;批量初始化&quot;">​</a></h2><p>左边指定作为初始化模板的存储器的 ID，上端指定用于储存初始化结果的存储器的 ID，后端输入起始偏移位置和其他参数，右端输入范围，下端变为 256 V (0x100) 时，范围内和模板相同类型的存储器会被初始化为与模板一致</p><h3 id="端口定义-1" tabindex="-1">端口定义 <a class="header-anchor" href="#端口定义-1" aria-label="Permalink to &quot;端口定义&quot;">​</a></h3>',6),v=JSON.parse('{"title":"多存储器操作器","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"zh/expand/memory_banks/memory_banks_operator.md","filePath":"zh/expand/memory_banks/memory_banks_operator.md"}'),I={name:"zh/expand/memory_banks/memory_banks_operator.md"},H=x({...I,setup(k){let p=[new e(n.Top,a.Output,r.Hide,[new t(1,32,"将结果输出到指定 ID 的存储器","")],!1,!0),new e(n.Right,a.Input,r.Hide,[new t(1,32,"指定右边存储器 ID","")],!1,!0),new e(n.Bottom,a.Input,r.Hide,[new t(1,32,"同步操作，详见下表","")],!1,!0),new e(n.Left,a.Input,r.Hide,[new t(1,32,"指定左边存储器 ID","")],!1,!0),new e(n.In,a.Input,r.Hide,[new t(1,32,"同步操作的参数","")],!1,!0)],h=[new e(n.Top,a.Output,r.Hide,[new t(1,32,"将结果输出到指定 ID 的存储器（必须指定）","")],!1,!0),new e(n.Right,a.Input,r.StartAndEnd,[new t(1,8,"X 轴范围大小","单位格，方向为西"),new t(9,16,"Y 轴范围大小","单位格，方向为上"),new t(17,24,"Z 轴范围大小","单位格，方向为北"),new t(25,25,"X 轴范围的符号","为 1 时，X 轴范围的方向改为向东"),new t(26,26,"Y 轴范围的符号","为 1 时，Y 轴范围的方向改为向下"),new t(27,27,"Z 轴范围的符号","为 1 时，Z 轴范围的方向改为向南"),new t(28,32,"空白","无作用")]),new e(n.Bottom,a.Input,r.Hide,[new t(1,32,"变为 256 V (0x100) 时，尝试初始化","")],!1,!0),new e(n.Left,a.Input,r.Hide,[new t(1,32,"指定作为初始化模板的存储器 ID","")],!1,!0),new e(n.In,a.Input,r.StartAndEnd,[new t(1,8,"X 轴偏移大小",`单位格，方向为西  
偏移是指起始位置相对于多存储器操作器所在位置的偏移`),new t(9,16,"Y 轴偏移大小","单位格，方向为上"),new t(17,24,"Z 轴偏移大小","单位格，方向为北"),new t(25,25,"X 轴偏移的符号","为 1 时，X 轴偏移的方向改为向东"),new t(26,26,"Y 轴偏移的符号","为 1 时，Y 轴偏移的方向改为向下"),new t(27,27,"Z 轴偏移的符号","为 1 时，Z 轴偏移的方向改为向南"),new t(28,28,"是否不输出结果","为 1 时不将结果输出到上端输入指定 ID 的存储器，为 0 时则输出<br/>无论是否输出结果，均要在上端指定一个有效存储器"),new t(29,29,"是否覆盖","为 1 时将会覆盖已有数据的存储器，为 0 时不覆盖"),new t(30,32,"空白","无作用")])];return(D,q)=>{const m=y("Badge");return u(),b("div",{"data-pagefind-body":!0},[s("h1",g,[d("多存储器操作器 "),l(m,{text:"v1.0",type:"info"}),d(),f]),w,l(o,{imgAltPrefix:"多存储器操作器",connections:i(p),imgSrc:"/images/expand/memory_banks/GVMemoryBanksOperatorBlock.webp",titleLevel:4,serial:1},null,8,["connections"]),_,l(o,{imgAltPrefix:"多存储器操作器",connections:i(h),imgSrc:"/images/expand/memory_banks/GVMemoryBanksOperatorBlock.webp",titleLevel:4,serial:2},null,8,["connections"])])}}});export{v as __pageData,H as default};
